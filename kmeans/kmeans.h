// C++ implementation of K-Means clustering for n-dimensional data.
//
// This class follows the standard Expectation-Maximization iterative algorithm,
// also known by Lloyd's algorithm:
//   Repeat until convergence:
//      - Assign all points to the nearest cluster.
//      - Compute the cluster mean based on its assigned points.
//   Convergence is when the cluster assignment doesn't change.
//   The initialization of the means uses k random points from the data.
//
// Author: Felix Duvallet

#ifndef __KMEANS_KMEANS_H__
#define __KMEANS_KMEANS_H__

#include <map>
#include <string>
#include <vector>

#include "point.h"
#define CAL_SUM_DIRECT 1

class KMeans {
 public:
  // K is the number of clusters we want. Max iterations is just to prevent
  // running forever.
  KMeans(int k, int max_iterations = 100);

  // Copy all the given points.
  bool init(const std::vector<Point> &points);

  // Run until convergence.
  bool run();

  // Load the points from file and into the vector.
  static bool loadPoints(const std::string &filepath,
                         std::vector<Point> *points);
  static bool loadPoints(const int file_number_start, int file_count,
                         std::vector<Point> *points);
  void printMeans();

  // Write means to file, in the same format as the input file.
  void writeMeans(const std::string &filepath);

 protected:
  // Assign each point to the nearest cluster. Returns true if any point's
  // cluster assignment has changed, so we can detect convergence.
  bool assign();

  // Compute the means to be the average of all the points in each cluster.
  virtual bool update_means();
  
  // Returns the index of the cluster nearest to this point.
  int findNearestCluster(const Point &point);

  // Computes a new cluster mean (output parameter mean) using the points in
  // that cluster. The multimap is mapping from cluster_id -> Point* (it is
  // generated by update_means).
  void computeClusterMean(
    const std::multimap<int, const Point *> &multimap,
    int cluster,
    Point *mean);


  // Number of clusters, the means, and all the points stored.
  size_t num_clusters_;
  size_t max_iterations_;
  std::vector<Point> means_;
  std::vector<Point> points_;

 public:

 std::vector<std::pair<Point,int>> result; //<sum of cluster, points num of cluster>

 std::vector<std::pair<Point,int>> & getResult(){
    return result;
 }

 std::vector<Point>* getPoints() {
    return &points_;
  }

    //set new means value
  void set_means(std::vector<Point> n){
    means_ = n;
  }

 std::vector<Point> &get_means(void){
    return means_;
  }
static int size(std::vector<Point> &vp);
static int toBuf(std::vector<Point> &vp,void* buf, int bufLen);
static void fromBuf(std::vector<Point> &vp, void*buf, int len, int dim);
// return len in bytes
 int meansLen(void);

 // return len in bytes for real data len, input buf and len in bytes
void meansToBuf(void* buf, int bufLen);

 // return len in bytes
 int pointsLen(void);

 void pointsToBuf(void* buf, int bufLen);

 void meansFromBuf(void*buf, int len, int dim);

 void pointsFromBuf(void*buf, int len, int dim);

 int get_max_iterations(void){
    return max_iterations_;
 }

};

#endif  // __KMEANS_KMEANS_H__
